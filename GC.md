## GC类型
- Minor GC，新生代
- Major GC，老年代

## GC原理
### G1原理
- 标记阶段
  - 初始标记阶段：初始标记阶段是指从GC Roots出发标记全部直接子节点的过程，该阶段是STW的。由于GC Roots数量不多，通常该阶段耗时非常短。
  - 并发标记阶段：并发标记阶段是指从GC Roots开始对堆中对象进行可达性分析，找出存活对象。该阶段是并发的，即应用线程和GC线程可以同时活动。并发标记耗时相对长很多，但因为不是STW，所以我们不太关心该阶段耗时的长短。
  - 再标记阶段：重新标记那些在并发标记阶段发生变化的对象。该阶段是STW的。
- 清理阶段
  - 清理阶段清点出有存活对象的分区和没有存活对象的分区，该阶段不会清理垃圾对象，也不会执行存活对象的复制。该阶段是STW的。
- 复制阶段
  - 复制算法中的转移阶段需要分配新内存和复制对象的成员变量。转移阶段是STW的，其中内存分配通常耗时非常短，但对象成员变量的复制耗时有可能较长，这是因为复制耗时与存活对象数量与对象复杂度成正比。对象越复杂，复制耗时越长。
### 停顿分析
初始标记因为只标记GC Roots，耗时较短。再标记因为对象数少，耗时也较短。清理阶段因为内存分区数量少，耗时也较短。转移阶段要处理所有存活的对象，耗时会较长。因此，G1停顿时间的瓶颈主要是标记-复制中的转移阶段STW。
### ZGC原理
ZGC只有三个STW阶段：初始标记，再标记，初始转移。其中，初始标记和初始转移分别都只需要扫描所有GC Roots，其处理时间和GC Roots的数量成正比，一般情况耗时非常短；再标记阶段STW时间很短，最多1ms，超过1ms则再次进入并发标记阶段。即，ZGC几乎所有暂停都只依赖于GC Roots集合大小，停顿时间不会随着堆的大小或者活跃对象的大小而增加。与ZGC对比，G1的转移阶段完全STW的，且停顿时间随存活对象的大小增加而增加。

## GC收集器
### ZGC
- 停顿时间不超过10ms
- 停顿时间不会随着堆的大小，或者活跃对象的大小而增加
- 支持8MB~4TB级别的堆（未来支持16TB）
### G1
- 业务实测，Minor GC2次/分钟，停顿时间100ms/次；Major GC次数较少

## 参考文档
https://tech.meituan.com/2017/12/29/jvm-optimize.html  
https://tech.meituan.com/2020/08/06/new-zgc-practice-in-meituan.html
